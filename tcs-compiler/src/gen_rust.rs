//! Rust code generation for TCS schemas
//!
//! Generates Rust code with wincode derives for serialization/deserialization.

use tcs_schema::{Definition, DefinitionKind, Field, Schema};

use crate::utils::{escape_rust_keyword, to_pascal_case, to_snake_case};
use crate::verifier::NATIVE_TYPES;

/// Maps TCS types to Rust types
fn map_type(field: &Field, is_message: bool) -> String {
    let type_name = field.type_.as_deref().unwrap_or("");

    let rust_type = match type_name {
        "bool" => "bool".to_string(),
        "byte" => "u8".to_string(),
        "int" => "i32".to_string(),
        "uint" => "u32".to_string(),
        "float" => "f32".to_string(),
        "string" => "String".to_string(),
        "int64" => "i64".to_string(),
        "uint64" => "u64".to_string(),
        other => to_pascal_case(other),
    };

    // Handle arrays
    if field.is_array {
        if let Some(size) = field.array_size {
            // Fixed-size array: byte[32] -> [u8; 32]
            let inner = format!("[{}; {}]", rust_type, size);
            if is_message {
                format!("Option<{}>", inner)
            } else {
                inner
            }
        } else {
            // Variable-length array
            if is_message {
                format!("Option<Vec<{}>>", rust_type)
            } else {
                format!("Vec<{}>", rust_type)
            }
        }
    } else if is_message {
        format!("Option<{}>", rust_type)
    } else {
        rust_type
    }
}

/// Check if a type is a native/primitive type
#[allow(dead_code)]
fn is_native_type(type_name: &str) -> bool {
    NATIVE_TYPES.contains(&type_name)
}

/// Entry point: generate Rust code from a Schema
pub fn compile_schema_to_rust(schema: &Schema) -> String {
    let package = schema.package.clone();
    let mut rust_code: Vec<String> = Vec::new();

    // Header
    rust_code.push("// This file was generated by the TCS compiler.".to_string());
    rust_code.push("// Do not edit manually.".to_string());
    rust_code.push("".to_string());

    // If there's a package, wrap everything in a module
    if let Some(ref name) = package {
        rust_code.push(format!("pub mod {} {{", to_snake_case(name)));
        rust_code.push("".to_string());
    }

    // Imports
    rust_code.push("use wincode::{SchemaRead, SchemaWrite};".to_string());
    rust_code.push("".to_string());

    // Generate code for each definition
    for definition in &schema.definitions {
        match definition.kind {
            DefinitionKind::Enum => {
                rust_code.push(generate_enum(definition));
            }
            DefinitionKind::Struct => {
                rust_code.push(generate_struct(definition, false));
            }
            DefinitionKind::Message => {
                rust_code.push(generate_struct(definition, true));
            }
        }
        rust_code.push("".to_string());
    }

    // Close package module if needed
    if package.is_some() {
        rust_code.push("}".to_string());
    }

    rust_code.join("\n")
}

/// Generate a Rust enum with wincode derives
fn generate_enum(definition: &Definition) -> String {
    let enum_name = to_pascal_case(&definition.name);
    let mut lines = Vec::new();

    // Derives and attributes
    lines.push("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default, SchemaRead, SchemaWrite)]".to_string());
    lines.push("#[repr(u32)]".to_string());
    lines.push(format!("pub enum {} {{", enum_name));

    // Variants
    for (i, field) in definition.fields.iter().enumerate() {
        let var_name = escape_rust_keyword(&to_pascal_case(&field.name));
        let value = field.field_id;

        let mut variant_line = String::new();
        if field.is_deprecated {
            variant_line.push_str("    #[deprecated]\n");
        }
        // First variant is the default
        if i == 0 {
            variant_line.push_str("    #[default]\n");
        }
        variant_line.push_str(&format!("    {} = {},", var_name, value));
        lines.push(variant_line);
    }

    lines.push("}".to_string());
    lines.join("\n")
}

/// Generate a Rust struct with wincode derives
fn generate_struct(definition: &Definition, is_message: bool) -> String {
    let struct_name = to_pascal_case(&definition.name);
    let mut lines = Vec::new();

    // Derives and attributes
    lines.push("#[derive(Debug, Clone, PartialEq, Default, SchemaRead, SchemaWrite)]".to_string());

    // Use repr(C) for structs to ensure consistent memory layout
    if !is_message {
        lines.push("#[repr(C)]".to_string());
    }

    lines.push(format!("pub struct {} {{", struct_name));

    // Fields
    for field in &definition.fields {
        let rust_name = escape_rust_keyword(&to_snake_case(&field.name));
        let field_type = map_type(field, is_message);

        let mut field_lines = Vec::new();

        if field.is_deprecated {
            field_lines.push("    #[deprecated]".to_string());
        }

        field_lines.push(format!("    pub {}: {},", rust_name, field_type));
        lines.push(field_lines.join("\n"));
    }

    lines.push("}".to_string());

    // Add helper methods for the struct
    let impl_block = generate_struct_impl(definition, &struct_name);

    format!("{}\n\n{}", lines.join("\n"), impl_block)
}

/// Generate impl block with helper methods
fn generate_struct_impl(_definition: &Definition, struct_name: &str) -> String {
    let mut lines = Vec::new();

    lines.push(format!("impl {} {{", struct_name));

    // Serialize method
    lines.push("    /// Serialize this value to bytes".to_string());
    lines.push("    pub fn to_bytes(&self) -> Vec<u8> {".to_string());
    lines.push("        wincode::serialize(self).expect(\"serialization should not fail\")".to_string());
    lines.push("    }".to_string());
    lines.push("".to_string());

    // Deserialize method
    lines.push("    /// Deserialize from bytes".to_string());
    lines.push(format!(
        "    pub fn from_bytes(bytes: &[u8]) -> Result<Self, wincode::Error> {{"
    ));
    lines.push("        wincode::deserialize(bytes)".to_string());
    lines.push("    }".to_string());

    lines.push("}".to_string());

    lines.join("\n")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::parse_schema;
    use crate::tokenizer::tokenize_schema;

    fn generate(input: &str) -> String {
        let tokens = tokenize_schema(input).unwrap();
        let schema = parse_schema(&tokens).unwrap();
        compile_schema_to_rust(&schema)
    }

    #[test]
    fn test_generate_simple_struct() {
        let input = r#"
            struct Point {
                int x;
                int y;
            }
        "#;
        let output = generate(input);
        assert!(output.contains("pub struct Point"));
        assert!(output.contains("pub x: i32"));
        assert!(output.contains("pub y: i32"));
        assert!(output.contains("SchemaRead, SchemaWrite"));
        assert!(output.contains("#[repr(C)]"));
    }

    #[test]
    fn test_generate_fixed_byte_array() {
        let input = r#"
            struct BlockHeader {
                byte[32] prevHash;
                byte[32] merkleRoot;
            }
        "#;
        let output = generate(input);
        assert!(output.contains("pub prev_hash: [u8; 32]"));
        assert!(output.contains("pub merkle_root: [u8; 32]"));
    }

    #[test]
    fn test_generate_message() {
        let input = r#"
            message Transaction {
                byte[32] txHash = 1;
                uint64 nonce = 2;
                byte[] data = 3;
            }
        "#;
        let output = generate(input);
        assert!(output.contains("pub struct Transaction"));
        assert!(output.contains("pub tx_hash: Option<[u8; 32]>"));
        assert!(output.contains("pub nonce: Option<u64>"));
        assert!(output.contains("pub data: Option<Vec<u8>>"));
        // Messages don't have repr(C)
        assert!(!output.contains("#[repr(C)]") || output.matches("#[repr(C)]").count() == 0);
    }

    #[test]
    fn test_generate_enum() {
        let input = r#"
            enum NodeRole {
                STORAGE = 1;
                VALIDATOR = 2;
                LIGHT = 3;
            }
        "#;
        let output = generate(input);
        assert!(output.contains("pub enum NodeRole"));
        assert!(output.contains("#[repr(u32)]"));
        assert!(output.contains("Storage = 1"));
        assert!(output.contains("Validator = 2"));
        assert!(output.contains("#[default]"));
    }

    #[test]
    fn test_generate_with_package() {
        let input = r#"
            package tapedrive;

            struct Blob {
                byte[] data;
            }
        "#;
        let output = generate(input);
        assert!(output.contains("pub mod tapedrive {"));
        assert!(output.contains("}"));
    }

    #[test]
    fn test_rust_keyword_escape() {
        let input = r#"
            struct Config {
                string type;
                int match;
            }
        "#;
        let output = generate(input);
        assert!(output.contains("pub type_: String"));
        assert!(output.contains("pub match_: i32"));
    }
}
